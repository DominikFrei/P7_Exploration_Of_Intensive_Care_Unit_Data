---
title: "P7_Survival_After_Indwelling_Arterial_Catheters_Use"
author: "Dominik Frei"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width=10, fig.height=8, fig.fullwidth=TRUE)
```

## Resources

Data Source: https://physionet.org/content/mimic2-iaccd/1.0/


# Code

## Set up

Libraries:
```{r message=FALSE}
library(tidyverse)
library(knitr)
library(caret)
library(Amelia) #missmap()
library(mice) #imputation
library(Hmisc) #rcorr()
```
Language:
```{r}
Sys.setenv(LANG = "en")
```

## Load and Preprocess Data

Load in the data set:
```{r}
data <- read.csv(file = "Data/full_cohort_data.csv",
                 stringsAsFactors = TRUE)
```

Convert all the binary variables into factors:
```{r define factors}
for (i in 1:ncol(data)) {
        if(length(unique(data[,i])) == 2) {
                data[,i] <- as.factor(data[,i])
        }
}
```


Display the data structure as imported:
```{r}
str(data)
```
`gender_num` and `sepsis_flg` should also be factors:
```{r}
data$gender_num <- as.factor(data$gender_num)
data$sepsis_flg <- as.factor(data$sepsis_flg)

data[,c("gender_num", "sepsis_flg")] %>% str()
```
`sepsis_flg` will not be useful in our analysis, since all the values are the same
(it has zero variance). We can therefore drop it from our data:
```{r}
data <- data %>% select(!sepsis_flg)
```

## Exploratory Data Analysis

### Missing Values

Lets look at the missing value sof the data:
```{r missmap all}
missmap(data[,colSums(is.na(data)) > 0], main = "Missingness Map: All Patients")
```
The `bmi` variable contains around 400 NA values, which have adjacent indexes.
This is somewhat odd. It does not seem that the data was ordered for missing values
in `bmi`, since there are other NAs, outside of the missing chunk.

Is there anything special about these missing records?

The variable `weight_first` might be somehow related to bmi. Lets plot it versus the rowindex:
```{r}
data %>% ggplot(aes(x = as.numeric(rownames(.)), y = weight_first)) +
        geom_point() +
        theme_classic()
```
There doesnt seem to be a particular order to the weights in the dataframe.

Lets also include `bmi` in the plot:
```{r}
data %>% ggplot(aes(x = as.numeric(rownames(.)))) +
        geom_point(aes(y = weight_first)) +
        geom_point(aes(y = bmi, col = "red")) +
        theme_classic()
```
Here we see that the missing chunk for the is at the end of the data frame.
It starts at the row number 1387.

Does this coincide with any patterns in other variables?

Lets calculate means for all the numeric variables, for the part of the data, where
the `bmi` values are missing and the rest and then compare them:
```{r}
mean_missing <- data %>% select_if(is.numeric) %>% 
        filter(as.numeric(rownames(.)) >= 1387) %>% 
        summarise(colname = colnames(.), mean = colMeans(., na.rm = TRUE)) %>% 
        mutate(in_chunk = TRUE)
        

mean_missing <- data %>% select_if(is.numeric) %>% 
        filter(as.numeric(rownames(.)) < 1387) %>% 
        summarise(colname = colnames(.), mean = colMeans(., na.rm = TRUE)) %>% 
        mutate(in_chunk = FALSE) %>% 
        rbind(mean_missing)
        
mean_missing %>% ggplot(aes(x = colname, y = mean, fill = as.factor(in_chunk))) +
        geom_bar(stat = "identity", position = "dodge") +
        theme_classic() +
        coord_flip()
```
There arent any big differences in the means between the part of the dataframe, where `bmi`
is missing and the rest.

Lets look at the factor variables:
```{r}
mean_missing_f <- data %>% select_if(is.factor) %>% 
        sapply(.,as.numeric) %>% 
        as.data.frame() %>% 
        filter(as.numeric(rownames(.)) >= 1387) %>% 
        summarise(colname = colnames(.), mean = colMeans(., na.rm = TRUE)) %>% 
        mutate(in_chunk = TRUE)

mean_missing_f <- data %>% select_if(is.factor) %>% 
        sapply(.,as.numeric) %>% 
        as.data.frame() %>%
        filter(as.numeric(rownames(.)) < 1387) %>% 
        summarise(colname = colnames(.), mean = colMeans(., na.rm = TRUE)) %>% 
        mutate(in_chunk = FALSE) %>% 
        rbind(mean_missing_f)

mean_missing_f %>% ggplot(aes(x = colname, y = mean, fill = as.factor(in_chunk))) +
        geom_bar(stat = "identity", position = "dodge") +
        theme_classic() +
        coord_flip()
```
Here we just converted the factor levels into numeric values and then took the means.
This is only a quick solution. For factors with more than two levels, this doesnt 
necessarily show the differences perfectly.

It  seems here as well there are no obvious patterns in the other variables.

Now we will produce a dummy variable that indicates the records, where the `bmi`
value is missing and then calculate the pearson correlation of this with all
other variables:
```{r}
#produce missingness indicator variable
data_mis_ind <- data %>% mutate(bmi_missing = as.numeric(is.na(data$bmi)))

#select all the numeric variables
data_mis_ind_n <- data_mis_ind %>% select_if(is.numeric)

#transform all the factors to numeric
data_mis_ind <- data_mis_ind %>% select_if(is.factor) %>% 
        sapply(.,as.numeric) %>% 
        as.data.frame() %>%
        cbind(., data_mis_ind_n)

#perform cor tests and save results
mis_cor_results <- data.frame(matrix(nrow = 0, ncol = 3))

for (i in 1:(ncol(data_mis_ind)-1)) {
        test <- cor.test(data_mis_ind$bmi_missing, data_mis_ind[,i], method = "pearson")
        res <- cbind(colnames(data_mis_ind)[i], test$estimate[[1]], test$p.value)
        mis_cor_results <- rbind(mis_cor_results, res)
}

#rename columns
colnames(mis_cor_results) <- c("var_name", "cor", "p_val")

#order for p value and present
mis_cor_results %>% arrange(p_val) %>% filter(p_val < 0.05) %>% kable()
```
There arent any strong correlations.

The reason why exactly these values are missing remains unclear.

Is there any correlation between `weight_first` and `bmi`?
```{r}
data %>% ggplot(aes(x = weight_first, y = bmi)) +
        geom_point() +
        theme_classic()
```

```{r}
cor.test(data$bmi, data$weight_first)
```
There is significant correlation between `weight_first` and `bmi` (which is not
surprising, since bmi is calculated using weight and height). The remaining variation
in the `bmi` is due to variances in height of the people. Unfortunately we dont know height.
Nevertheless, `weight_first` would be useful if we want to impute the missing values of`bmi`.

Lets look at the rest of the missing values. In the missingness plot, above there does not 
seem to be too much of a pattern. There are some patients with several missing values.
The reason for this is probably that these variables are normally captured/recorded together
(e.g. blood co2 and oxygen levels or anamnesis => all the `_flg` variables) and where not
captured/recorded for certain patients.

Show counts of missing values:
```{r}
sapply(data, function(x) sum(is.na(x))) %>% 
        .[which(. > 0)] %>% 
        sort(decreasing = TRUE) %>% 
        data.frame()
```
We will later impute the missing values.

### Variance?

Lets look at the variablility in certain variables. Especially for the "flag variables"
I suspect there could be very low values, which can lead to problems (near zero variance).

Calculate the percentage in the data that have a positive (1) value for the flag
variables:
```{r}
data %>% select(ends_with("_flg")) %>% 
        sapply(function(x) as.numeric(x)-1) %>% 
        data.frame() %>% 
        colMeans() %>% 
        sort() %>% 
        data.frame() %>% 
        mutate(perc_flagged = .*100) %>% 
        select(!.) %>% 
        kable(digits = 2)
```
Some of the variables really do have a low variance e.g. `renal_flg` only contains 
ca. 3 percent of positive values.

We can use the caret::nearZeroVar function to identify near zero variables in
all of the data:
```{r}
nearZeroVar(data, saveMetrics = TRUE) %>% filter(zeroVar == TRUE | nzv == TRUE)
```
Here renal_flg is found to be the only near zero variable in the data set 
(we had already removed `sepsis_flg` earlier, which had zero variance).

### Variables with Information about Death

Some of the flag variables above are actually not flags for for medical conditions,
but contain information about death of patients or if an IAC was used on them:
- `censor_flg`: censored or death (binary: 0 = death, 1 = censored)  
- `day_28_flg`: death within 28 days (binary: 1 = yes, 0 = no)  
- `hosp_exp_flg`: death in hospital (binary: 1 = yes, 0 = no)
- `icu_exp_flg`: death in ICU (binary: 1 = yes, 0 = no)  
- `aline_flg`: IAC used (binary, 1 = year, 0 = no) 
- `mort_day_censored`: day post ICU admission of censoring or death (days, numeric)
# explore var further

Lets plot a correlation matrix:
```{r}
#subset for these variables
data_death <- data %>% select(censor_flg, day_28_flg, hosp_exp_flg, icu_exp_flg, mort_day_censored, aline_flg)
#correlation matrix
rcorr(as.matrix(data_death))
```

`aline_flg` correlates significantly with `hosp_exp_flg` and `icu_exp_flg` and close
to significantly with `day_28_flg`. The correlation coefficients however are quite small
for all of them. This indicates that either the use of an AIC increases the risk for
death or patients with a higher risk of death are more likely to receive monitoring via IAC.

What exactly is the relation between 

Lets look at contingency tables between `day_28_flg` and `hosp_exp_flg` / `icu_exp_flg`?
Can `hosp_exp_flg` / `icu_exp_flg` only be positive if `day_28_flg` is positive?

Produce contingency tables:
```{r}
table(data$day_28_flg, data$hosp_exp_flg, dnn = c("day_28_flg", "hosp_exp_flg"))

table(data$day_28_flg, data$icu_exp_flg, dnn = c("day_28_flg", "icu_exp_flg"))
```
No, there are three patients that died in the hospital, but not within 28 days.

However from the correlations of `day_28_flg` with `hosp_exp_flg` / `icu_exp_flg`
we see that many of them died in the ICU or in the hospital

Lets look at the contingency table of `day_28_flg` with `censor_flg`:
```{r}
table(data$day_28_flg, data$censor_flg, dnn = c("day_28_flg", "censor_flg"))
```
We see that there are no discrepancies between the variables (dead within 28 days but not
registered as dead in `censor_flg`)

### Physiological Measurements

Lets look at all the variables that contain physiological measurements or similar 
(ending in _1st or _first):
```{r}
#subset
data_meas <- data %>% select(ends_with("_1st") | ends_with("_first"))

#scale
data_meas <- data_meas %>% sapply(., scale) %>% data.frame()

#pivot longer and create indicators for outliers
data_meas <- data_meas %>% pivot_longer(cols = colnames(.)) %>% 
        group_by(name) %>% 
        mutate(outlier = as.factor(ifelse((value>3*IQR(value, na.rm = TRUE) | value <(-3*IQR(value, na.rm = TRUE))), 1, 0)))
```

Produce density plots to present the distribution of the data (outliers (>3*IQR) are marked
by red ticks)
```{r fig.height=5}
data_meas %>% filter(name %in% unique(.$name)[1:6]) %>% 
        ggplot(aes(x = value)) +
        facet_wrap(~ name) +
        geom_density() +
        geom_rug(data = ~ filter(.x, outlier == 1), col = "red") +
        coord_cartesian(ylim = c(0, 1)) +
        theme_bw()
```
- `spo2_1st` is left skewed. The variable measures Saturation of Peripheral Oxygen
in percent, which normally is between 95% – 99%. So the distribution here makes sense. 

Lets look at the lowest values:
```{r}
data %>% arrange(spo2_1st) %>% select(spo2_1st) %>% .[1:20,]
```
There are some very low values. Lets look at the records with values below 50:
```{r}
data %>% filter(spo2_1st < 50) %>%  select(spo2_1st, po2_first, icu_los_day, hospital_los_day, sapsi_first, sofa_first, service_num,
                                           hosp_exp_flg, icu_exp_flg, day_28_flg, mort_day_censored) %>% kable()
```
We can see that 4 of the 6 patients survived.

The po2 scores are not especially low, only one value is below 80 mmHg.

The SAPS I scores are not that high (all < 29). For the SAPS II score, this would
indicate a mortality rate of < 10 %
according to (https://clincalc.com/IcuMortality/SAPSII.aspx).
I did not find anything about SAPS I in a quick search.
It has to be noted, that SPO2 is not used in the calculation of SAPS II

For the SOFA score the maximal value is 24, so the values are not that critical either.

# weiter



- There are some high values for `weight_first`, which is plausible (obese patients).  
- There is an extremely low value for `temp_1st`. lets have a look at it:
```{r}
data$temp_1st %>% min(., na.rm = TRUE)
```
Temperature is coded in Fahrenheit. In Celsius it is:
```{r}
(32-32)/1.8
```
This is clearly impossible, therefore we will replace this value with NA and will impute it later
together with the other data:
```{r}
data[data$temp_1st == 32 & is.na(data$temp_1st) == FALSE, "temp_1st"] <- NA
```

The other distributions are more or less symmetric.
```{r fig.height=5}
data_meas %>% filter(name %in% unique(.$name)[7:12]) %>% 
        ggplot(aes(x = value)) +
        facet_wrap(~ name) +
        geom_density() +
        geom_rug(data = ~ filter(.x, outlier == 1), col = "red") +
        theme_bw()
```
All are more or less symmetric.
```{r fig.height=5}
data_meas %>% filter(name %in% unique(.$name)[13:18]) %>% 
        ggplot(aes(x = value)) +
        facet_wrap(~ name) +
        geom_density() +
        geom_rug(data = ~ filter(.x, outlier == 1), col = "red") +
        theme_bw()
```
`bun_first` and `po2_first` are a bit right skewed.
- `bun_first`: first Blood urea nitrogen (mg/dL, numeric): higher values could indicate
 decrease in glomerular filtration rate, which in turn is suggestive of kidney failure.
- `po2_first`: Partial Pressure of Oxygen in blood (mmHg, numeric): high values dont
have a specific medical implication.

We would expect a certain correlation with `renal_flg`. Lets check this:
```{r}
cor.test(data$bun_first, as.numeric(data$renal_flg))
```
There is a statistically significant correlation between the two

```{r}
data %>% str()
```

-------

The main question we will pose is: Which of the available variables in the data set are useful
for predicting death within 28 days, after the use of an indwelling arterial catheter (IAC)?

It is important to note that these risk factors will likely not be very specific
for the use of AIC but might be just general risk factors.

Are there sufficient records for patients on which an IAC was used?
```{r}
table(data$aline_flg)
```

Subset the data and drop the `aline_flg` variable:
```{r}
data_sub <- data %>% filter(aline_flg == 1) %>% 
        select(!aline_flg)
```

Lets look at missing values.
Produce a missingnes plot for all the columns where there are missing values:
```{r}
missmap(data_sub[,colSums(is.na(data_sub)) > 0], main = "Missingness Map: Patients with AIC")
```



We will try to impute the missing values by using the mice::mice function.

It might be useful to have more data to do this, so we will do the imputation on
the whole data set.
Lets first look at a missingnes map of the whole dataset.


Fo the complete dataset, there is overall a bit more data missing and some variables
contain relatively more missing values. The overall patern (a chunk of missing values
for `bmi`) however, is the same.

Perform imputation only for subet data:
```{r message=FALSE, cache=TRUE}
#data_imp <- mice(data_sub)
```

```{r}
#plot(data_imp)
```


- Use vif to assess multicolinearity.